<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" >
<title>Go 指南</title>

<!-- jQuery -->
<script src="static/jquery.js"></script>

<!-- Fonts -->
<link href='http://fonts.googleapis.com/css?family=Droid+Serif&v1' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Droid+Sans&v1' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Droid+Sans+Mono&v1' rel='stylesheet' type='text/css'>

<!-- Playground -->
<link rel="stylesheet" href="/static/codemirror/lib/codemirror.css">
<script src="/static/codemirror/lib/codemirror.js"></script>
<link rel="stylesheet" href="/static/codemirror/theme/default.css">
<script src="static/playground.js"></script>

<!-- Tour -->
<link rel="stylesheet" href="static/tour.css" charset="utf-8">
<script src="static/mode.js"></script>
<script src="static/tour.js"></script>

</head>
<body class="loading">

<!-- Top bar -->
<h2 id="slidenum"></h2>
<div id="topnav" class="nav">
	<button id="tocbtn">目录</button>
</div>
<h1>Go 指南</h1>

<!-- Loading message -->
<div id="loading">
	加载幻灯……
</div>

<!-- Table of Contents -->
<ol id="toc"></ol>

<div id="slides" class="slides"><!-- begin slides -->

<div class="toc">欢迎</div>

<div class="slide">
	<h2>Hello, 世界</h2>
	<p>
	欢迎来到<a target="_blank" href="http://golang.org/">Go 编程语言</a>指南.
        <p>
        该指南被分为三节。在每节的末尾有若干个练习需要读者完成。
	<p>
        该指南可以进行交互。点击“Run”按钮（或按 Shift + Enter）可以在<span class="appengineMode">远程服务器上</span><span class="localMode">你的电脑上</span>编译并执行程序。
        结果展示在代码的下面。
	<p>
        这些例子程序展示了 Go 的各个方面。在指南中的程序可以成为你积累经验的开始。
	<p>
	编辑程序并且再次执行它。
        <p>
        当你准备好继续了，点击“Next”按钮或按 PageDown 键。
<div>
package main

import "fmt"

func main() {
	fmt.Println("Hello, 世界")
}
</div>
</div>

<div class="slide nocode appengineMode">
	<h2>离线 Go 指南</h2>
        <p>
        该指南同样可以作为独立的程序用在没有互联网接入的情况下。
	<p>
        独立运行的指南更快，同时它在你本地的设备上构建和编译代码。它同时包括了一些在沙盒版本中没有的增强体验。
	<p>
        为了在本地运行指南首先要<a target="_blank" href="http://golang.org/doc/install.html">安装 Go</a>（最后的稳定版本，<code>release.r60</code>），然后使用
	<a target="_blank" href="http://golang.org/cmd/goinstall/">goinstall</a>
	安装
	<a target="_blank" href="http://code.google.com/p/go-tour/">gotour</a>：
        <pre>    goinstall go-tour.googlecode.com/hg/gotour</pre>
        <p>
        也可以安装<a target="_blank" href="http://bitbucket.org/mikespook/go-tour-zh/">中文版本</a>：
        <pre>    goinstall bitbucket.org/mikespook/go-tour-zh/gotour</pre>
	<p>
	最后执行安装产生的 <code>gotour</code> 执行文件。
        <p>
        如果不安装本地版本，点击“Next”按钮或者按 PageDown 继续。
	<p>
        <i>（可以在任何时候点击“目录”按钮返回这个介绍。）</i>
</div>

<div class="slide nocode appengineMode">
	<h2>本地化 Go 指南</h2>
	<p>
        该指南也有其他语言版本：
	<ul>
        <li><a href="http://tour.golang.org/">English &mdash; 英语</a></li>
        <li><a href="http://go-tour-jp.appspot.com/">Japanese &mdash; 日語</a></li>
	<li><a href="http://go-tour-kr.appspot.com/">Korean &mdash; 韩语</a></li>
	</ul>
	点击“Next”按钮或者按 PageDown 继续。
</div>

<div class="toc">简介</div>

<div class="slide">
	<h2>包</h2>
        <p>
        每个 Go 程序都是由包组成的。
	<p>
	程序运行的入口是包 <code>main</code>。
        <p>
        这个程序使用并导入了包
	<code>"fmt"</code> 和 <code>"math"</code>。
        <p>
        按照惯例，包名与导入路径的最后一个目录一致。
<div>
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println("Happy", math.Pi, "Day")
}
</div>
</div>

<div class="slide">
	<h2>导入</h2>
	<p>
        这个代码用园括号组合了导入，这是“factored”导入语句。同样可以编写多个导入语句，例如：
	<pre>
	import "fmt"
	import "math"
	</pre>
        不过通常都会用 factored 格式来使代码工整。
<div>
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Printf("Now you have %g problems.",
		math.Nextafter(2, 3))
}
</div>
</div>

<div class="slide">
	<h2>导出名</h2>
        <p>
        在导入了一个包之后，就可以用其导出的名称来调用它。
	<p>
        在 Go 中，首字母大写的名称是被导出的。
	<p>
	<code>Foo</code> 和 <code>FOO</code> 都是被导出的名称。
	名称 <code>foo</code> 是不会被导出的。
	<p>
	执行代码。然后将 <code>math.pi</code> 改名为 <code>math.Pi</code> 再试着执行一下。
<div>
package main

import (
	"fmt"
	"math"
)

func main() {
	fmt.Println(math.pi)
}
</div>
</div>

<div class="slide">
	<h2>函数</h2>
	<p>
	函数可以没有参数或接受多个参数。
	<p>
	在这个例子中，<code>add</code> 接受两个 <code>int</code> 类型的参数。
	<p>
        注意类型在变量名<i>之后</i>。
        <p>
	（参考<a target="_blank" href="http://blog.golang.org/2010/07/gos-declaration-syntax.html">这篇博文</a>了解类型为何以这种形式出现的原因。）
<div>
package main

import "fmt"

func add(x int, y int) int {
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}
</div>
</div>

<div class="slide">
	<h2>函数</h2>
        <p>
        当两个或多个连续的函数命名参数是同一类型，则除了最后一个类型之外，其他都可以省略。
	<p>
	在这个例子中 ，
        <pre>x int, y int</pre>
        <p>
        被缩写为
	<p>
	<pre>x, y int</pre>
<div>
package main

import "fmt"

func add(x, y int) int {
	return x + y
}

func main() {
	fmt.Println(add(42, 13))
}
</div>
</div>

<div class="slide">
	<h2>函数</h2>
	<p>
        函数可以返回任意数量的结果。
	<p>
	这个函数返回了两个字符串。
<div>
package main

import "fmt"

func swap(x, y string) (string, string) {
	return y, x
}

func main() {
	a, b := swap("hello", "world")
	fmt.Println(a, b)
}
</div>
</div>

<div class="slide">
	<h2>函数</h2>
        <p>
        函数接受参数；在 Go 中可以像变量那样对结果进行命名；这叫做“结果参数”。
	<p>
	如果命名了结果参数，一个没有参数的 <code>return</code> 语句，会将当前的值作为结果返回。
<div>
package main

import "fmt"

func split(sum int) (x, y int) {
	x = sum * 4/9
	y = sum - x
	return
}

func main() {
	fmt.Println(split(17))
}
</div>
</div>

<div class="slide">
	<h2>变量</h2>
	<p>
        <code>var</code> 语句定义了一个变量的列表；跟函数的参数列表一样，类型在最后。
<div>
package main

import "fmt"

var x, y, z int
var c, python, java bool

func main() {
	fmt.Println(x, y, z, c, python, java)
}
</div>
</div>

<div class="slide">
	<h2>变量</h2>
	<p>
        变量定义可以包含初始值，每个变量一个。
	<p>
        如果初始化是表达式，则可以省略类型；变量从初始值中获得类型。
<div>
package main

import "fmt"

var x, y, z int = 1, 2, 3
var c, python, java = true, false, "no!"

func main() {
	fmt.Println(x, y, z, c, python, java)
}
</div>
</div>

<div class="slide">
	<h2>变量</h2>
        <p>
        在函数中，<code>:=</code> 简洁赋值语句可以在恰当的地方用于简洁的 <code>var</code> 定义。
	<p>
         （<code>:=</code> 结构不能使用在函数外，函数外的每个结构都必须以关键字开始。）
<div>
package main

import "fmt"

func main() {
	var x, y, z int = 1, 2, 3
	c, python, java := true, false, "no!"

	fmt.Println(x, y, z, c, python, java)
}
</div>
</div>

<div class="slide">
	<h2>常量</h2>
        <p>
        常量的定义与变量类似，只不过使用 <code>const</code> 关键字。
	<p>
        常量可以是字符串、布尔或数字类型的值。
<div>
package main

import "fmt"

const Pi = 3.14

func main() {
	const World = "世界"
	fmt.Println("Hello", World)
	fmt.Println("Happy", Pi, "Day")

	const Truth = true
	fmt.Println("Go rules?", Truth)
}
</div>
</div>

<div class="slide">
	<h2>数值常量</h2>
	<p>
        数值常量是高精度的<i>值</i>。
        <p>
        一个未指定类型的常量由上下文来决定其类型。
	<p>
	也尝试一下输出 <code>needInt(Big)</code>吧。
<div>
package main

import "fmt"

const (
	Big = 1<<100
	Small = Big>>99
)

func needInt(x int) int { return x*10 + 1 }
func needFloat(x float64) float64 {
	return x*0.1
}

func main() {
	fmt.Println(needInt(Small))
	fmt.Println(needFloat(Small))
	fmt.Println(needFloat(Big))
}
</div>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	Go 只有一种循环结构，<code>for</code> 循环。
	<p>
        基本的 <code>for</code> 循环看起来跟 C 或者 Java 中做的一样，除了没有了 <code>( )</code> 之外（它们甚至连可选都不是），而 <code>{ }</code> 是必须的。
<div>
package main

import "fmt"

func main() {
	sum := 0
	for i := 0; i < 10; i++ {
		sum += i
	}
	fmt.Println(sum)
}
</div>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	跟 C 或者 Java 中一样，可以让前置、后置语句为空。
<div>
package main

import "fmt"

func main() {
	sum := 1
	for ; sum < 1000; {
		sum += sum
	}
	fmt.Println(sum)
}
</div>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
        基于此可以省略分号：
	C 的 <code>while</code> 在 Go 中也是用 <code>for</code> 实现。
<div>
package main

import "fmt"

func main() {
	sum := 1
	for sum < 1000 {
		sum += sum
	}
	fmt.Println(sum)
}
</div>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	如果省略了循环条件，它就是个死循环源。
<div>
package main

func main() {
	for ; ; {
	}
}
</div>
</div>

<div class="slide">
	<h2>For</h2>
	<p>
	而为了避免累赘，分号可以省略，因此一个死循环可以简洁的表达。
<div>
package main

func main() {
	for {
	}
}
</div>
</div>

<div class="slide">
	<h2>If</h2>
	<p>
	<code>if</code> 语句看起来跟 C 或者 Java 中的一样，除了没有了 <code>( )</code> 之外（它们甚至连可选都不是），而 <code>{ }</code> 是必须的。
	<p>
        （耳熟吗？）
<div>
package main

import (
	"fmt"
	"math"
)

func sqrt(x float64) string {
	if x < 0 {
		return sqrt(-x) + "i"
	}
	return fmt.Sprint(math.Sqrt(x))
}

func main() {
	fmt.Println(sqrt(2), sqrt(-4))
}
</div>
</div>

<div class="slide">
	<h2>If</h2>
	<p>
	跟 <code>for</code> 一样，<code>if</code> 语句可以在条件之前执行一个简单的语句。
        <p>
        由这个语句定义的变量的作用域仅在 <code>if</code> 范围之内。
	<p>
        （在最后的 <code>return</code> 语句处使用 <code>v</code> 看看。）
<div>
package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	}
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}
</div>
</div>

<div class="slide">
	<h2>If</h2>
        <p>
        在 <code>if</code> 的简单语句处定义的变量同样可以在任何对应的 <code>else</code> 块中使用。
<div>
package main

import (
	"fmt"
	"math"
)

func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	} else {
		fmt.Printf("%g >= %g\n", v, lim)
	}
        // 不能在这里使用 v，因此
	return lim
}

func main() {
	fmt.Println(
		pow(3, 2, 10),
		pow(3, 3, 20),
	)
}
</div>
</div>

<div class="slide">
	<h2>基本类型</h2>
	<p>
	Go 的基本类型有
	<pre>
bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

float32 float64

complex64 complex128
	</pre>
<div>
package main

import (
	"cmath"
	"fmt"
)

var (
	ToBe bool = false
	MaxInt uint64 = 1<<64 - 1
	z complex128 = cmath.Sqrt(-5+12i)
)

func main() {
	const f = "%T(%v)\n"
	fmt.Printf(f, ToBe, ToBe)
	fmt.Printf(f, MaxInt, MaxInt)
	fmt.Printf(f, z, z)
}
</div>
</div>

<div class="slide">
	<h2>结构体</h2>
	<p>
        一个结构体（<code>struct</code>）就是一个字段的集合。
	<p>
	（而 <code>type</code> 定义跟其字面意思相符。）
<div>
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	fmt.Println(Vertex{1, 2})
}
</div>
</div>

<div class="slide">
	<h2>结构体字段</h2>
        <p>
        结构体字段使用点号来访问。
<div>
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	v := Vertex{1, 2}
	v.X = 4
	fmt.Println(v.X)
}
</div>
</div>

<div class="slide">
	<h2>指针</h2>
	<p>
        Go 有指针，但是没有指针运算。
	<p>
	结构题字段可以通过结构体指针来访问。通过指针间接的访问是透明的。
<div>
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	p := Vertex{1, 2}
	q := &p
	q.X = 1e9
	fmt.Println(p)
}
</div>
</div>

<div class="slide">
	<h2>结构体文法</h2>
        <p>
        结构体文法表示通过结构体字段的值作为列表来新分配一个结构体。
	<p>
        使用 <code>Name:</code> 语法可以仅列出部分字段。（字段名的顺序无关。）
	<p>
        特殊的前缀 <code>&</code> 构造了指向结构体文法的指针。
<div>
package main

import "fmt"

type Vertex struct {
	X, Y int
}

var (
	p = Vertex{1, 2}  // has type Vertex
	q = &Vertex{1, 2} // has type *Vertex
	r = Vertex{X: 1}  // Y:0 is implicit
	s = Vertex{}      // X:0 and Y:0
)

func main() {
	fmt.Println(p, q, r, s)
}
</div>
</div>

<div class="slide">
	<h2><code>new</code>  函数</h2>
	<p>
	表达式 <code>new(T)</code> 分配了一个零初始化的 <code>T</code> 值，并返回指向它的指针。
	<pre>var t *T = new(T)</pre>
	<p>
	或
	<pre>t := new(T)</pre>
<div>
package main

import "fmt"

type Vertex struct {
	X, Y int
}

func main() {
	v := new(Vertex)
	fmt.Println(v)
	v.X, v.Y = 11, 9
	fmt.Println(v)
}
</div>
</div>

<div class="slide">
	<h2>Map</h2>
	<p>
        map 映射键到值。
	<p>
        <!-- TODO: empty part not true in compilers yet -->
        map 在使用之前必须用 <code>make</code> 来创建（不是 <code>new</code>）；一个值为 <code>nil</code> 的 map 是空的，并且不能赋值。
<div>
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m map[string]Vertex

func main() {
	m = make(map[string]Vertex)
	m["Bell Labs"] = Vertex{
		40.68433, 74.39967,
	}
	fmt.Println(m["Bell Labs"])
}
</div>
</div>

<div class="slide">
	<h2>Map</h2>
	<p>
        map 的文法跟结构体文法相似，不过键是必须的。
<div>
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m = map[string]Vertex{
	"Bell Labs": Vertex{
		40.68433, -74.39967,
	},
	"Google": Vertex{
		37.42202, -122.08408,
	},
}

func main() {
	fmt.Println(m)
}
</div>
</div>

<div class="slide">
	<h2>Map</h2>
	<p>
        如果顶层类型就是类型名子的话，可以在文法的元素中省略它。
<div>
package main

import "fmt"

type Vertex struct {
	Lat, Long float64
}

var m = map[string]Vertex{
	"Bell Labs": {40.68433, -74.39967},
	"Google":    {37.42202, -122.08408},
}

func main() {
	fmt.Println(m)
}
</div>
</div>

<div class="slide">
	<h2>Slice</h2>
	<p>
        slice 指向数组的值，并且同时包含了长度信息。
	<p>
	<code>[]T</code> 是一个元素类型为 <code>T</code> 的 slice。
<div>
package main

import "fmt"

func main() {
	p := []int{2, 3, 5, 7, 11, 13}
	fmt.Println("p ==", p)

	for i := 0; i < len(p); i++ {
		fmt.Printf("p[%d] == %d\n",
			i, p[i])
	}
}
</div>
</div>

<div class="slide">
	<h2>Slice</h2>
        <p>
        slice 可以重新切片，创建一个新的 slice 值指向相同的数组。
	<p>
	表达式
	<pre>s[lo:hi]</pre>
        <p>
        表示从 <code>lo</code> 到 <code>hi-1</code> 的 slice 元素，含有两端。
        因此 <pre>s[lo:lo]</pre> 
	<p>
	是空的，而
	<pre>s[lo:lo+1]</pre>
        <p>
        有一个元素。
<div>
package main

import "fmt"

func main() {
	p := []int{2, 3, 5, 7, 11, 13}
	fmt.Println("p ==", p)
	fmt.Println("p[1:4] ==", p[1:4])

	// missing low index implies 0
	fmt.Println("p[:3] ==", p[:3])

	// missing high index implies len(s)
	fmt.Println("p[4:] ==", p[4:])
}
</div>
</div>

<div class="slide">
	<h2>Slice</h2>
	<p>
        slice 由函数 <code>make</code> 创建。这会分配一个零长度的数组并且返回一个 slice 指向这个数组：
	<pre>
a := make([]int, 5)  // len(a)=5
        </pre>
        slice 有长度和容量。slice 的容量是底层数组可以增长的最大长度。
	<p>
        为了指定容量，可传递第三个参数到 <code>make</code>：
	<p>
	<pre>
b := make([]int, 0, 5)
// len(b)=0, cap(b)=5
        </pre>
        slice 可以通过“重新切片”来扩容（增长到容量上限）：
	<p>
	<pre>
b = b[:cap(b)] // len(b)=5, cap(b)=5
b = b[1:]      // len(b)=4, cap(b)=4
	</pre>
<div>
package main

import "fmt"

func main() {
	a := make([]int, 5)
	printSlice("a", a)
	b := make([]int, 0, 5)
	printSlice("b", b)
	c := b[:2]
	printSlice("c", c)
	d := c[2:5]
	printSlice("d", d)
}

func printSlice(s string, x []int) {
	fmt.Printf("%s len=%d cap=%d %v\n",
		s, len(x), cap(x), x)
}
</div>
</div>

<div class="slide">
	<h2>Slice</h2>
	<p>
	slice 的零值是 <code>nil</code>。
        <p>
        一个 nil 的 slice 的长度和容量是 0。
	<p>
	<i>参阅文章“<a target="_blank" href="http://blog.golang.org/2011/01/go-slices-usage-and-internals.html">Go Slices: usage and internals</a>”了解更多信息。</i>
<div>
package main

import "fmt"

func main() {
	var z []int
	fmt.Println(z, len(z), cap(z))
	if z == nil {
		fmt.Println("nil!")
	}
}
</div>
</div>

<div class="slide">
	<h2>函数</h2>
        <p>
        函数也是值。
<div>
package main

import (
	"fmt"
	"math"
)

func main() {
	hypot := func(x, y float64) float64 {
		return math.Sqrt(x*x + y*y)
	}

	fmt.Println(hypot(3, 4))
}
</div>
</div>

<div class="slide">
	<h2>函数</h2>
        <p>
        并且函数是完全闭包的。
	<p>
	函数 <code>adder</code> 返回一个闭包。每个闭包被绑定到了特定的 <code>sum</code> 变量上。
<div>
package main

import "fmt"

func adder() func(int) int {
	sum := 0
	return func(x int) int {
		sum += x
		return sum
	}
}

func main() {
	pos, neg := adder(), adder()
	for i := 0; i < 10; i++ {
		fmt.Println(
			pos(i),
			neg(-2*i),
		)
	}
}
</div>
</div>

<div class="slide">
	<h2>Range</h2>
	<p>
        <code>for</code> 循环的 <code>range</code> 格式可以对 slice 或者 map 进行迭代循环。
<div>
package main

import "fmt"

var pow = []int{1, 2, 4, 8, 16, 32, 64, 128}

func main() {
	for i, v := range pow {
	    fmt.Printf("2**%d = %d\n", i, v)
	}
}
</div>
</div>

<div class="slide">
	<h2>Range</h2>
	<p>
        可以将值赋值给 <code>_</code> 来忽略键和值。
        <p>
        如果只需要索引值，去掉&ldquo;<code>, value</code>&rdquo;的部分即可。
<div>
package main

import "fmt"

func main() {
	pow := make([]int, 10)
	for i := range pow {
		pow[i] = 1&lt;&lt;uint(i)
	}
	for _, value := range pow {
		fmt.Printf("%d\n", value)
	}
}
</div>
</div>

<div class="slide">
	<h2>Switch</h2>
	<p>
	你可能已经猜到 <code>switch</code> 可能的形式了。
        <p>
        case 体会自动终止，除非用 <code>fallthrough</code> 语句作为结尾。

<div>
package main

import (
	"fmt"
	"runtime"
)

func main() {
	fmt.Print("Go runs on ")
	switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("OS X.")
	case "linux":
		fmt.Println("Linux.")
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf("%s.", os)
	}
}
</div>
</div>

<div class="slide">
	<h2>Switch</h2>
	<p>
        switch 的条件从上到下的执行，当匹配成功的时候停止。
	<p>
	（例如，
	<pre>
switch i {
case 0:
case f():
}</pre>
        <p>
        当 <code>i==0</code> 时不会调用 <code>f</code>。）

<div>
package main

import (
	"fmt"
	"time"
)

func main() {
	fmt.Println("When's Saturday?")
	today := time.LocalTime().Weekday
	switch time.Saturday {
	case today+0:
		fmt.Println("Today.")
	case today+1:
		fmt.Println("Tomorrow.")
	case today+2:
		fmt.Println("In two days.")
	default:
		fmt.Println("Too far away.")
	}
}
</div>
</div>

<div class="slide">
	<h2>Switch</h2>
	<p>
	没有条件的 switch 同 <code>switch true</code> 一样。

<div>
package main

import (
	"fmt"
	"time"
)

func main() {
	t := time.LocalTime()
	switch {
	case t.Hour < 12:
	    fmt.Println("Good morning!")
	case t.Hour < 17:
	    fmt.Println("Good afternoon.")
	default:
	    fmt.Println("Good evening.")
	}
}
</div>
</div>

<div class="slide">
	<h2>练习：循环和函数</h2>
        <p>
        作为练习函数和循环的简单途径，用牛顿法实现开方函数。
        <p>
        在这个例子中，牛顿法是通过选择一个初始点 <i>z</i> 然后重复这一过程求 <code>Sqrt(x)</code> 的近似值：
	<center>
	<img src="https://chart.googleapis.com/chart?cht=tx&chl=z=z-\frac{z^2-x}{2z}">
        </center>
        <p>
        为了做到这个，只需要重复计算 10 次，并且观察不同的值（1，2，3，……）是如何逐步逼近结果的。
        <p>
        然后，修改循环条件，使得当值停止改变（或改变非常小）的时候退出循环。观察迭代次数是否变化。结果与 <a target="_blank" href="http://golang.org/pkg/math/#Sqrt">math.Sqrt</a> 接近吗？
        <p>
        提示：定义并初始化一个浮点值，向其提供一个浮点语法或使用转换：
	<pre>
	z := float64(0)
	z := 0.0
	</pre>

<div>
package main

import (
	"fmt"
)

func Sqrt(x float64) float64 {
}

func main() {
	fmt.Println(Sqrt(2))
}
</div>
</div>

<div class="slide">
	<h2>练习：Map</h2>
	<p>
        实现 <code>WordCount</code>。它应当返回一个含有 <code>s</code> 中每个 &ldquo;word&rdquo; 数量的 map。函数 <code>wc.Test</code> 针对这个函数执行一个测试用例，并打印成功或者失败。
	<p>
        你会发现 <a target="_blank" href="http://golang.org/pkg/strings/#Fields">strings.Fields</a> 很有帮助。

<div>
package main

import (
	"<span class="appengineMode">tour</span><span class="localMode">go-tour.googlecode.com/hg</span>/wc"
)

func WordCount(s string) map[string]int {
	return map[string]int{"x": 1}
}

func main() {
	wc.Test(WordCount)
}
</div>
</div>

<div class="slide">
	<h2>练习：Slice</h2>
	<p>
        实现 <code>Pic</code>。它应当接受一个 slice 的长度 <code>dy</code>，和 slice 中每个元素的长度的 8 位无符号整数 <code>dx</code>。当执行这个程序，它会将整数转换为灰度（好吧，蓝度）图片进行展示。
        <p>
        图片的实现已经完成。可能用到的函数包括 <code>x^y</code>，<code>(x+y)/2</code> 和 <code>x*y</code>。
	<p>
	（需要使用循环来分配 <code>[][]uint8</code> 中的每个 <code>[]uint8</code>。）

<div>
package main

import "<span class="appengineMode">tour</span><span class="localMode">go-tour.googlecode.com/hg</span>/pic"

func Pic(dx, dy int) [][]uint8 {
}

func main() {
	pic.Show(Pic)
}
</div>
</div>

<div class="slide">
	<h2>练习：斐波纳契闭包</h2>
        <p>
        现在来通过函数找些乐趣。
	<p>
        实现一个 <code>fibonacci</code> 函数，返回一个函数（一个闭包）可以返回连续的斐波纳契数。
<div>
package main

import "fmt"

// fibonacci is a function that returns
// a function that returns an int.
func fibonacci() func() int {
}

func main() {
	f := fibonacci()
	for i := 0; i < 10; i++ {
		fmt.Println(f())
	}
}
</div>
</div>

<div class="slide">
	<h2>进阶练习：复数立方根</h2>
	<p>
        让我们通过 <code>complex64</code> 和 <code>complex128</code> 来探索一下 Go 内建的复数。
        对于立方根，牛顿法需要大量循环：
	<center>
	<img src="https://chart.googleapis.com/chart?cht=tx&chl=z=z-\frac{z^3-x}{3z^2}">
	</center>
	<p>
        找到 2 的立方根，确保算法能够工作。
	这里有 <a target="_blank" href="http://golang.org/pkg/cmath/#Pow">cmath.Pow</a> 函数。

<div>
package main

import "fmt"

func Cbrt(x complex128) complex128 {
}

func main() {
	fmt.Println(Cbrt(2))
}
</div>
</div>


<div class="toc">方法和接口</div>

<div class="slide nocode">
<h2>方法和接口</h2>
</div>

<div class="slide">
	<h2>方法</h2>
        <p>
        Go 没有类。然而，仍然可以在结构体类型上定义方法。
	<p>
        <i>方法接收者</i>出现在 <code>func</code> 关键字和方法名之间的参数中。
<div>
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := &Vertex{3, 4}
	fmt.Println(v.Abs())
}
</div>
</div>

<div class="slide">
	<h2>方法</h2>
        <p>
        事实上，可以对包中的<i>任意</i>类型定义任意方法，而不仅仅是结构体。
        <p>
        不能对来自其他包的类型或基础类型定义方法。
<div>
package main

import (
	"fmt"
	"math"
)

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f < 0 {
		return float64(-f)
	}
	return float64(f)
}

func main() {
	f := MyFloat(-math.Sqrt2)
	fmt.Println(f.Abs())
}
</div>
</div>

<div class="slide">
	<h2>接收者为指针的方法</h2>
        <p>
        方法可以与命名类型或命名类型的指针关联。
	<p>
        刚刚看到的两个 <code>Abs</code> 方法。一个是在 <code>*Vertex</code> 指针类型上，而另一个在 <code>MyFloat</code> 值类型上。
        <p>
        有两个原因需要使用指针接收者。首先避免在每个方法调用中拷贝值（如果值类型是大的结构体的话会更有效率）。其次，方法可以修改接收者指向的值。
	</ol>
	<p>
        尝试修改 <code>Abs</code> 的定义，同时 <code>Scale</code> 方法使用 <code>Vertex</code> 代替 <code>*Vertex</code> 作为接收者。
	<p>
        当 <code>v</code> 是 <code>Vertex</code> 的时候 <code>Scale</code> 方法没有任何作用。<code>Scale</code> 修改 <code>v</code>。当 <code>v</code> 是一个值（非指针），方法看到的是 <code>Vertex</code> 的副本，并且无法修改原始值。
	<p>
	<code>Abs</code> 的工作方式是一样的。只不过，仅仅读取 <code>v</code>。所以读取的是原始值（通过指针）还是那个值的副本并没有关系。
<div>
package main

import (
	"fmt"
	"math"
)

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := &Vertex{3, 4}
	v.Scale(5)
	fmt.Println(v, v.Abs())
}
</div>
</div>

<div class="slide">
	<h2>Interfaces</h2>
	<p>
	An interface type is defined by a set of methods.
	<p>
	A value of interface type can hold any value that
	implements those methods.

<div>
package main

import (
	"fmt"
	"math"
)

type Abser interface {
	Abs() float64
}

func main() {
	var a Abser
	f := MyFloat(-math.Sqrt2)
	v := Vertex{3, 4}

	a = f  // a MyFloat implements Abser
	a = &v // a *Vertex implements Abser
	a = v  // a Vertex, does NOT
	       // implement Abser

	fmt.Println(a.Abs())
}

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f < 0 {
		return float64(-f)
	}
	return float64(f)
}

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
</div>
</div>

<div class="slide">
	<h2>Interfaces</h2>
	<p>
	A type implements an interface by implementing the methods.
	<p>
	<i>There is no explicit declaration of intent.</i>
	<p>
	Implicit interfaces decouple implementation packages from the packages
	that define the interfaces: neither depends on the other.
	<p>
	It also encourages the definition of precise interfaces, because you
	don't have to find every implementation and tag it with the new
	interface name.
	<p>
	<a target="_blank" href="http://golang.org/pkg/io/">Package io</a> defines <code>Reader</code> and <code>Writer</code>; you don't have to.
<div>
package main

import (
	"fmt"
	"os"
)

type Reader interface {
	Read(b []byte) (n int, err os.Error)
}

type Writer interface {
	Write(b []byte) (n int, err os.Error)
}

type ReadWriter interface {
	Reader
	Writer
}

func main() {
	var w Writer

	// os.Stdout implements Writer
	w = os.Stdout

	fmt.Fprintf(w, "hello, writer\n")
}
</div>
</div>

<div class="slide">
	<h2>Errors</h2>
	<p>
	An error is anything that can describe itself:
	<pre>
package os

type Error interface {
	String() string
}
	</pre>

<div>
package main

import (
	"fmt"
	"os"
	"time"
)

type MyError struct {
	When *time.Time
	What string
}

func (e *MyError) String() string {
	return fmt.Sprintf("at %v, %s",
		e.When, e.What)
}

func run() os.Error {
	return &MyError{
		time.LocalTime(),
		"it didn't work",
	}
}

func main() {
	if err := run(); err != nil {
		fmt.Println(err)
	}
}
</div>
</div>

<div class="slide">
	<h2>Web servers</h2>
	<p>
	<a target="_blank" href="http://golang.org/pkg/http/">Package http</a> serves HTTP requests using any value
	that implements <code>http.Handler</code>:
	<pre>
package http

type Handler interface {
	ServeHTTP(w ResponseWriter,
	          r *Request)
}
	</pre>
	<p>
	In this example, the type <code>MyHandler</code> implements <code>http.Handler</code>.
	<p>
	<span class="localMode">
	Visit <a href="http://localhost:4000/" target="_blank">http://localhost:4000/</a> to see the greeting.
	</span>
	<span class="appengineMode">
	<b>Note:</b> This example won't run through the web-based tour user
	interface. To try writing web servers you may want to
	<a target="_blank" href="http://golang.org/doc/install.html">Install
	Go</a>.
	</span>
<div>
package main

import (
	"fmt"
	"http"
)

type Hello struct{}

func (h Hello) ServeHTTP(
		w http.ResponseWriter,
		r *http.Request) {
	fmt.Fprint(w, "Hello!")
}

func main() {
	var h Hello
	http.ListenAndServe("localhost:4000",h)
}
</div>
</div>

<div class="slide">
	<h2>Images</h2>
	<p>
	<a target="_blank" href="http://golang.org/pkg/image/#Image">Package image</a> defines the <code>Image</code>
	interface:
	<pre>
package image

type Image interface {
	ColorModel() ColorModel
	Bounds() Rectangle
	At(x, y int) Color
}</pre>
	<p>
	(See <a target="_blank" href="http://golang.org/pkg/image/#Image">the
	documentation</a> for all the details.)
	<p>
	<code>Color</code> and <code>ColorModel</code> are interfaces too,
	but we'll ignore that by using the predefined implementations
	<code>image.RGBAColor</code> and <code>image.RGBAColorModel</code>.

<div>
package main

import (
	"fmt"
	"image"
)

func main() {
	m := image.NewRGBA(100, 100)
	fmt.Println(m.Bounds())
	fmt.Println(m.At(0, 0).RGBA())
}
</div>
</div>

<div class="slide">
	<h2>Exercise: Errors</h2>
	<p>
	Copy your <code>Sqrt</code> function from the earlier exercises and
	modify it to return an <code>os.Error</code> value.
	<p>
	<code>Sqrt</code> should return a non-nil error value when given a
	negative number, as it doesn't support complex numbers.
	<p>
	Create a new type
	<pre>
type ErrNegativeSqrt float64</pre>
	<p>
	and make it an <code>os.Error</code> by giving it a 
	<pre>
func (e ErrNegativeSqrt) String() string</pre>
	<p>
	method such that <code>ErrNegativeSqrt(-2).String()</code> returns
	<code>"cannot Sqrt negative number: -2"</code>.
	<p>
	<b>Note:</b> a call to <code>fmt.Print(e)</code> inside the
	<code>String</code> method will send the program into an infinite loop.
	You can avoid this by converting <code>e</code> first:
	<code>fmt.Print(float64(e))</code>. Why?
	<p>
	Change your <code>Sqrt</code> function to return an
	<code>ErrNegativeSqrt</code> value when given a negative number.
<div>
package main

import (
	"fmt"
	"os"
)

func Sqrt(f float64) (float64, os.Error) {
	return 0, nil
}

func main() {
	fmt.Println(Sqrt(2))
	fmt.Println(Sqrt(-2))
}
</div>
</div>

<div class="slide localMode">
	<h2>Exercise: HTTP Handlers</h2>
	<p>
	Implement the following types and define ServeHTTP methods on them.
	Register them to handle specific paths in your web server.
<pre>type String string
	
type Struct struct {
	Greeting string
	Punct    string
	Who      string
}</pre>
	<p>
	For example, you should be able to register handlers using:
<pre>http.Handle("/string", String("I'm a frayed knot."))
http.Handle("/struct", &Struct{"Hello", ":", "Gophers!"})</pre>
<div>
package main

import (
	"http"
)

func main() {
	// your http.Handle calls here
	http.ListenAndServe("localhost:4000", nil)
}
</div>
</div>

<div class="slide">
	<h2>Exercise: Images</h2>
	<p>
	Remember the picture generator you wrote earlier?
	Let's write another one, but this time it will return
	an implementation of <code>image.Image</code> instead of a slice of data.
	<p>
	Define your own <code>Image</code> type, implement
	<a target="_blank" href="http://golang.org/pkg/image/#Image" target="_blank">the necessary methods</a>,
	and call <code>pic.ShowImage</code>.
	<p>
	<code>Bounds</code> should return a <code>image.Rectangle</code>, like
	<code>image.Rect(0, 0, w, h)</code>.
	<p>
	<code>ColorModel</code> should return <code>image.RGBAColorModel</code>.
	<p>
	<code>At</code> should return a color;
	the value <code>v</code> in the last picture generator corresponds to
	<code>image.RGBAColor{v, v, 255, 255}</code> in this one.

<div>
package main

import (
	"image"
	"<span class="appengineMode">tour</span><span class="localMode">go-tour.googlecode.com/hg</span>/pic"
)

type Image struct{}

func main() {
	m := Image{}
	pic.ShowImage(m)
}
</div>
</div>

<div class="slide">
	<h2>Exercise: Rot13 Reader</h2>
	<p>
	A common pattern is an
	<a target="_blank" href="http://golang.org/pkg/io/#Reader">io.Reader</a> that wraps
	another <code>io.Reader</code>, modifying the stream in some way.
	<p>
	For example, the
	<a target="_blank" href="http://golang.org/pkg/compress/gzip/#Decompressor.NewReader">gzip.NewReader</a>
	function takes an <code>io.Reader</code> (a stream of gzipped data)
	and returns a <code>*gzip.Decompressor</code> that also implements
	<code>io.Reader</code> (a stream of the decompressed data).
	<p>
	Implement a <code>rot13Reader</code> that implements
	<code>io.Reader</code> and reads from an <code>io.Reader</code>,
	modifying the stream by applying the
	<a target="_blank" href="http://en.wikipedia.org/wiki/ROT13">ROT13</a>
	substitution cipher to all alphabetical characters.
	<p>
	The <code>rot13Reader</code> type is provided for you.  Make it an
	<code>io.Reader</code> by implementing its <code>Read</code> method.
<div>
package main

import (
	"io"
	"os"
	"strings"
)

type rot13Reader struct {
	r io.Reader
}

func main() {
	s := strings.NewReader(
		"Lbh penpxrq gur pbqr!")
	r := rot13Reader{s}
	io.Copy(os.Stdout, &r)
}
</div>
</div>

<div class="toc">并发</div>

<div class="slide nocode">
<h2>Concurrency</h2>
</div>

<div class="slide">
	<h2>Goroutines</h2>
	<p>
	A <i>goroutine</i> is a lightweight thread managed by the Go runtime.
	<pre>go f(x, y, z)</pre>
	<p>
	starts a new goroutine running
	<pre>f(x, y, z)</pre>
	<p>
	The evaluation
        of <code>f</code>, <code>x</code>, <code>y</code>, and <code>z</code>
        happens in the current goroutine and the execution of <code>f</code>
	happens in the new goroutine.
	<p>
	Goroutines run in the same address space, so access to shared memory
	must be synchronized. The <code><a href="http://golang.org/pkg/sync/"
	target="_blank">sync</a></code> package provides useful primitives,
	although you won't need them much in Go as there are other primitives.
	(See the next slide.)
<div>
package main

import (
	"fmt"
	"<span class="appengineMode">runtime</span><span class="localMode">time</span>"
)

func say(s string) {
	for i := 0; i < 5; i++ {
		<span class="appengineMode">runtime.Gosched()</span><span class="localMode">time.Sleep(100e6)</span>
		fmt.Println(s)
	}
}

func main() {
	go say("world")
	say("hello")
}
</div>
</div>

<div class="slide">
	<h2>Channels</h2>

	<p>
	Channels are a typed conduit through which you can send and receive values with the channel operator, <code>&lt;-</code>.
<pre>
ch <- v    // Send v to channel ch.
v := <-ch  // Receive from ch, and
           // assign value to v.
</pre>
	<p>
	(The data flows in the direction of the "arrow".)

	<p>
	Like maps and slices, channels must be created before use:
<pre>
ch := make(chan int)
</pre>

	<p>
	By default, sends and receives block until the other side is ready.
	This allows goroutines to synchronize without explicit locks or
	condition variables.
<div>
package main

import "fmt"

func sum(a []int, c chan int) {
	sum := 0
	for _, v := range a {
		sum += v
	}
	c <- sum  // send sum to c
}

func main() {
	a := []int{7, 2, 8, -9, 4, 0}

        c := make(chan int)
	go sum(a[:len(a)/2], c)
	go sum(a[len(a)/2:], c)
        x, y := <-c, <-c  // receive from c

	fmt.Println(x, y, x + y)
}
</div>
</div>


<div class="slide">
	<h2>Buffered Channels</h2>
	
	<p>
	Channels can be <i>buffered</i>.  Provide the buffer length as the
	second argument to <code>make</code> to initialize a buffered channel:
<pre>
ch := make(chan int, 100)
</pre>

	<p>
	Sends to a buffered channel block only when the buffer is full.
	Receives block when the buffer is empty.

	<p>
	Modify the example to overfill the buffer and see what happens.

<div>
package main

import "fmt"

func main() {
	c := make(chan int, 2)
	c <- 1
	c <- 2
	fmt.Println(<-c)
	fmt.Println(<-c)
}
</div>
</div>

<div class="slide">
	<h2>Range and Close</h2>
	<p>
	A sender can <code>close</code> a channel to indicate that no more
	values will be sent. Receivers can test whether a channel has been
	closed by assigning a second parameter to the receive expression: after
	<pre>
v, ok := &lt;-ch</pre>
	<p>
	<code>ok</code> is <code>false</code> if there are no more values to
	receive and the channel is closed.
	<p>
	The loop <code>for i := range c</code> receives values from the
	channel repeatedly until it is closed.
	<p>
	<b>Note:</b> Only the sender should close a channel, never the
	receiver. Sending on a closed channel will cause a panic.
	<p>
	<b>Another note</b>: Channels aren't like files; you don't usually
	need to close them. Closing is only necessary when the receiver must be
	told there are no more values coming.
<div>
package main

import (
	"fmt"
)

func fibonacci(n int, c chan int) {
        x, y := 1, 1
        for i := 0; i < n; i++ {
                c <- x
                x, y = y, x + y
        }
        close(c)
}

func main() {
        c := make(chan int, 10)
	go fibonacci(cap(c), c)
        for i := range c {
                fmt.Println(i)
        }
}
</div>
</div>

<div class="slide">
	<h2>Select</h2>
	<p>
	The <code>select</code> statement lets a goroutine wait on multiple
	communication operations.
	<p>
	A <code>select</code> blocks until one of its cases can run, then it
	executes that case.  It chooses one at random if multiple are ready.
<div>
package main

import "fmt"

func fibonacci(c, quit chan int) {
        x, y := 1, 1
        for {
                select {
                case c <- x:
                          x, y = y, x + y
                case <-quit:
			fmt.Println("quit")
                        return
                }
        }
}

func main() {
        c := make(chan int)
	quit := make(chan int)
	go func() {
		for i := 0; i < 10; i++ {
			fmt.Println(<-c)
		}
		quit <- 0
	}()
	fibonacci(c, quit)
}
</div>
</div>

<div class="slide">
	<h2>Default Selection</h2>
	<p>
	The <code>default</code> case in a <code>select</code> is run if no
	other case is ready.
	<p>
	Use a <code>default</code> case to try a send or receive without
	blocking:
	<pre>
select {
case i := <-c:
	// use i
default:
	// receiving from c would block
}</pre>
	<p>
	<span class="appengineMode">
	<b>Note:</b> This example won't run through the web-based tour user
	interface because the
	<a target="_blank" href="http://golang.org/doc/play/">sandbox
	environment</a> has no concept of time. You may want to
	<a target="_blank" href="http://golang.org/doc/install.html">install
	Go</a> to see this example in action.
	</span>
<div>
package main

import (
	"fmt"
	"time"
)

func main() {
        tick := time.Tick(1e8)
        boom := time.After(5e8)
        for {
                select {
                case <-tick:
                        fmt.Println("tick.")
                case <-boom:
                        fmt.Println("BOOM!")
                        return
                default:
                        fmt.Println("    .")
                        time.Sleep(5e7)
                }
        }
}
</div>
</div>

<div class="slide nocode">
	<h2>Exercise: Equivalent Binary Trees</h2>
	<p>
	There can be many different binary trees with the same sequence of
	values stored at the leaves.
	For example, here are two binary trees storing the sequence
	1, 1, 2, 3, 5, 8, 13.
	<img src="static/fig4.png">
	<p>
	A function to check whether two binary trees store the same sequence is
	quite complex in most languages. We'll use Go's concurrency and
	channels to write a simple solution.
	<p>
	This example uses the <code>tree</code> package, which defines the type:
<pre>
type Tree struct {
	Left  *Tree
	Value int
	Right *Tree
}
</pre>
</div>

<div class="slide">
	<h2>Exercise: Equivalent Binary Trees</h2>
	<p>
	<b>1.</b> Implement the <code>Walk</code> function.
	<p>
	<b>2.</b> Test the <code>Walk</code> function.
	<p>
	The function <code>tree.New(k)</code> constructs a randomly-structured
	binary tree holding the values <code>k</code>, <code>2k</code>, <code>3k</code>, ...,
	<code>10k</code>.
	<p>
	Create a new channel <code>ch</code> and kick off the walker:
<pre>
go Walk(tree.New(1), ch)
</pre>
	<p>
	Then read and print 10 values from the channel.
	It should be the numbers 1, 2, 3, ..., 10.
	<p>
	<b>3.</b> Implement the <code>Same</code> function using <code>Walk</code>
	to determine whether <code>t1</code> and <code>t2</code> store the same values.
	<p>
	<b>4.</b> Test the <code>Same</code> function. 
	<p>
	<code>Same(tree.New(1), tree.New(1))</code> should return true, and
	<code>Same(tree.New(1), tree.New(2))</code> should return false.

<div>
package main

import "<span class="appengineMode">tour</span><span class="localMode">go-tour.googlecode.com/hg</span>/tree"

// Walk walks the tree t sending all values
// from the tree to the channel ch.
func Walk(t *tree.Tree, ch chan int)

// Same determines whether the trees
// t1 and t2 contain the same values.
func Same(t1, t2 *tree.Tree) bool

func main() {
}
</div>
</div>

<div class="slide">
	<h2>Exercise: Web Crawler</h2>
	<p>
	In this exercise you'll use Go's concurrency features to
	parallelize a web crawler.
	<p>
	Modify the <code>Crawl</code> function to fetch URLs in parallel
	without fetching the same URL twice.
<div>
package main

import (
	"os"
	"fmt"
)

type Fetcher interface {
	// Fetch returns the body of URL and
	// a slice of URLs found on that page.
	Fetch(url string) (body string, urls []string, err os.Error)
}

// Crawl uses fetcher to recursively crawl
// pages starting with url, to a maximum of depth.
func Crawl(url string, depth int, fetcher Fetcher) {
	// TODO: Fetch URLs in parallel.
	// TODO: Don't fetch the same URL twice.
	// This implementation doesn't do either:
	if depth <= 0 {
		return
	}
	body, urls, err := fetcher.Fetch(url)
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Printf("found: %s %q\n", url, body)
	for _, u := range urls {
		Crawl(u, depth-1, fetcher)
	}
	return
}

func main() {
	Crawl("http://golang.org/", 4, fetcher)
}


// fakeFetcher is Fetcher that returns canned results.
type fakeFetcher map[string]*fakeResult

type fakeResult struct {
	body string
	urls     []string
}

func (f *fakeFetcher) Fetch(url string) (string, []string, os.Error) {
	if res, ok := (*f)[url]; ok {
		return res.body, res.urls, nil
	}
	return "", nil, fmt.Errorf("not found: %s", url)
}

// fetcher is a populated fakeFetcher.
var fetcher = &fakeFetcher{
	"http://golang.org/": &fakeResult{
		"The Go Programming Language",
		[]string{
			"http://golang.org/pkg/",
			"http://golang.org/cmd/",
		},
	},
	"http://golang.org/pkg/": &fakeResult{
		"Packages",
		[]string{
			"http://golang.org/",
			"http://golang.org/cmd/",
			"http://golang.org/pkg/fmt/",
			"http://golang.org/pkg/os/",
		},
	},
	"http://golang.org/pkg/fmt/": &fakeResult{
		"Package fmt",
		[]string{
			"http://golang.org/",
			"http://golang.org/pkg/",
		},
	},
	"http://golang.org/pkg/os/": &fakeResult{
		"Package os",
		[]string{
			"http://golang.org/",
			"http://golang.org/pkg/",
		},
	},
}
</div>
</div>

<div class="slide nocode">
	<h2>Where to Go from here...</h2>
	<p class="appengineMode">
	You can get started by
	<a href="http://golang.org/doc/install.html">installing Go</a> or
	downloading the
	<a href="http://code.google.com/appengine/downloads.html#Google_App_Engine_SDK_for_Go">Go App Engine SDK</a>.
	</p>
	<p>
	<span class="appengineMode">Once you have Go on your machine, the</span>
	<span class="localMode">The</span>
	<a target="_blank" href="http://golang.org/doc/docs.html">Go Documentation</a>
	is a great place to
	<span class="appengineMode">continue</span>
	<span class="localMode">start</span>.
	It contains references, tutorials, videos, and more.
	<p>
	If you need help with the standard library,
	see the <a target="_blank" href="http://golang.org/pkg/">package
	reference</a>.  For help with the language itself, you might be
	surprised to find the
	<a target="_blank" href="http://golang.org/doc/go_spec.html">Language
	Spec</a> is quite readable.
	<p>
	If you're interested in writing web applications,
	see the
	<a target="_blank" href="http://golang.org/doc/codelab/wiki/">Wiki
	Codelab</a>.
	<p>
	If you want to further explore Go's concurrency model, see the
	<a target="_blank" href="http://golang.org/doc/codewalk/sharemem/">Share Memory by Communicating</a>
	codewalk.
	<p>
	The <a target="_blank" href="http://golang.org/doc/codewalk/functions/">First Class Functions in Go</a>
	codewalk gives an interesting perspective on Go's function types.
	<p>
	The <a target="_blank" href="http://blog.golang.org/">Go Blog</a> has a
	large archive of informative Go articles.
	<p>
	Visit <a target="_blank" href="http://golang.org">golang.org</a> for
	more.
</div>

</div><!-- end slides -->

</body>
</html>
