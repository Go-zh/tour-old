Go 指南

Go 作者组
http://golang.org

# Throughout this file are a series of lines that begin with
# the string "#appengine: ". These lines are included in
# the tour content when deployed as an App Engine app.
# Furthermore, a single non-blank line that immediately follows
# a run of "#appengine: " lines will be hidden. This is so that
# App Engine-specific content may replace existing content.
# For example, this paragraph
# 	We are running
# 	#appengine: on App Engine.
# 	locally.
# 	Yay!
# reads as "We are running on App Engine. Yay!" on App Engine,
# and "We are running locally. Yay!" otherwise.

* Hello, 世界

欢迎来到[[http://golang.org/][Go 编程语言]]指南。

该指南被分为三个部分：基础概念、方法和接口，以及并发。

在指南后有若干个练习需要读者完成。

该指南可以进行交互。点击“运行”按钮（或按 Shift + Enter）可以在
#appengine: 远程服务器上
你的电脑上
编译并执行程序。
结果展示在代码的下面。

这些例子程序展示了 Go 的各个方面。在指南中的程序可以成为你积累经验的开始。

编辑程序并且再次执行它。

当你准备好继续了，点击“向后”按钮或按 PageDown 键。

.play prog/hello.go

* Go 本地化

该指南也有其他语言版本：

- [[http://go-tour-br.appspot.com/][Brazilian Portuguese — Português do Brasil]]
- [[http://go-tour-ca.appspot.com/][Catalan — Català]]
- [[http://go-tour-es.appspot.com/][Spanish — Español]]
- [[http://go-tour-fr.appspot.com/][French - Français]]
- [[http://go-tour-he.appspot.com/][Hebrew — עִבְרִית]]
- [[http://go-tour-jp.appspot.com/][Japanese — 日本語]]
- [[http://go-tour-ro.appspot.com/][Romanian - Română]]
- [[http://go-tour-zh.appspot.com/][Chinese — 普通话]]

点击“向后”按钮或者按 PageDown 继续。

* 包

每个 Go 程序都是由包组成的。

程序运行的入口是包 `main`。

这个程序使用并导入了包 `"fmt"` 和 `"math"`。

按照惯例，包名与导入路径的最后一个目录一致。

.play prog/packages.go

* 导入

这个代码用圆括号组合了导入，这是“factored”导入语句。同样可以编写多个导入语句，例如：

    import "fmt"
    import "math"

.play prog/imports.go

* 导出名

在导入了一个包之后，就可以用其导出的名称来调用它。

在 Go 中，首字母大写的名称是被导出的。

`Foo` 和 `FOO` 都是被导出的名称。名称 `foo` 是不会被导出的。

执行代码。然后将 `math.pi` 改名为 `math.Pi` 再试着执行一下。

.play prog/exported-names.go

* 函数

函数可以没有参数或接受多个参数。
        
在这个例子中，`add` 接受两个 `int` 类型的参数。
    
注意类型在变量名 _之后_。

（参考 [[http://golang.org/doc/articles/gos_declaration_syntax.html][这篇关于 Go 语法定义的文章]]了解类型以这种形式出现的原因。）

.play prog/functions.go

* 函数（续）
        
当两个或多个连续的函数命名参数是同一类型，则除了最后一个类型之外，其他都可以省略。
        
在这个例子中 ，

    x int, y int

被缩写为

    x, y int

.play prog/functions-continued.go

* 多值返回

函数可以返回任意数量的返回值。

这个函数返回了两个字符串。

.play prog/multiple-results.go

* 命名返回值

函数接受参数。在 Go 中，函数可以返回多个“结果参数”，而不仅仅是一个值。它们可以像变量那样命名和使用。

如果命名了返回值参数，一个没有参数的 `return` 语句，会将当前的值作为返回值返回。

.play prog/named-results.go

* 变量
        
`var` 语句定义了一个变量的列表；跟函数的参数列表一样，类型在后面。

.play prog/variables.go

* 初始化变量

变量定义可以包含初始值，每个变量对应一个。

如果初始化是使用表达式，则可以省略类型；变量从初始值中获得类型。

.play prog/variables-with-initializers.go

* 短声明变量

在函数中，`:=` 简洁赋值语句在明确类型的地方，可以用于替代 `var` 定义。

（`:=` 结构不能使用在函数外，函数外的每个语法块都必须以关键字开始。）

.play prog/short-variable-declarations.go

* 基本类型

Go 的基本类型有Basic types

    bool

    string
	
    int  int8  int16  int32  int64
    uint uint8 uint16 uint32 uint64 uintptr
	
    byte // uint8 的别名
	
    rune // int32 的别名
    // 代表一个Unicode码
	
    float32 float64
	
    complex64 complex128

.play prog/basic-types.go

* 常量

常量的定义与变量类似，只不过使用 `const` 关键字。

常量可以是字符、字符串、布尔或数字类型的值。

.play prog/constants.go

* 数值常量

数值常量是高精度的 _值_。

一个未指定类型的常量由上下文来决定其类型。

也尝试一下输出 `needInt(Big)` 吧。

.play prog/numeric-constants.go

* for

Go 只有一种循环结构——`for` 循环。

基本的 `for` 循环除了没有了 `( )` 之外（甚至强制不能使用它们），看起来跟 C 或者 Java 中做的一样，而 `{ }` 是必须的。

.play prog/for.go

* for（续）
        
跟 C 或者 Java 中一样，可以让前置、后置语句为空。

.play prog/for-continued.go

* for 是 Go 的 “while”
        
基于此可以省略分号：C 的 `while` 在 Go 中叫做 `for`。

.play prog/for-is-gos-while.go

* 死循环

如果省略了循环条件，循环就不会结束，因此可以用更简洁地形式表达死循环。

.play prog/forever.go

* if

`if` 语句除了没有了 `( )` 之外（甚至强制不能使用它们），看起来跟 C 或者 Java 中的一样，而 `{ }` 是必须的。
        
（耳熟吗？）

.play prog/if.go

* if 的便捷语句

跟 `for` 一样，`if` 语句可以在条件之前执行一个简单的语句。

由这个语句定义的变量的作用域仅在 `if` 范围之内。

（在最后的 `return` 语句处使用 `v` 看看。）

.play prog/if-with-a-short-statement.go

* if 和 else

在 `if` 的便捷语句定义的变量同样可以在任何对应的 `else` 块中使用。

.play prog/if-and-else.go

* 练习：循环和函数

作为练习函数和循环的简单途径，用牛顿法实现开方函数。

在这个例子中，牛顿法是通过选择一个初始点 _z_ 然后重复这一过程求 `Sqrt(x)` 的近似值：

.image static/newton.png

为了做到这个，只需要重复计算 10 次，并且观察不同的值（1，2，3，……）是如何逐步逼近结果的。
   然后，修改循环条件，使得当值停止改变（或改变非常小）的时候退出循环。观察迭代次数是否变化。结果与 [[http://golang.org/pkg/math/#Sqrt][math.Sqrt] 接近吗？

提示：定义并初始化一个浮点值，向其提供一个浮点语法或使用转换：

    z := float64(1)
    z := 1.0

.play prog/exercise-loops-and-functions.go

* 结构体

一个结构体（`struct`）就是一个字段的集合。

（而 `type` 的含义跟其字面意思相符。）

.play prog/structs.go

* 结构体字段

结构体字段使用点号来访问。

.play prog/struct-fields.go

* 指针

Go 有指针，但是没有指针运算。

结构体字段可以通过结构体指针来访问。通过指针间接的访问是透明的。

.play prog/pointers.go

* 结构体文法

结构体文法表示通过结构体字段的值作为列表来新分配一个结构体。

使用 `Name:` 语法可以仅列出部分字段。（字段名的顺序无关。）

特殊的前缀 `&` 构造了指向结构体的指针。

.play prog/struct-literals.go

* new 函数
        
表达式 `new(T)` 分配了一个零初始化的 `T` 值，并返回指向它的指针。

    var t *T = new(T)

或

    t := new(T)

.play prog/the-new-function.go

# TODO(campoy): Arrays section

* slice
        
slice 指向一个数组，并且包含了长度信息。

`[]T` 是一个元素类型为 `T` 的 slice。

.play prog/slices.go

* 对 slice 切片

slice 可以重新切片，创建一个新的 slice 值指向相同的数组。

表达式

    s[lo:hi]
        
表示从 `lo` 到 `hi-1` 的 slice 元素，含两端。因此

    s[lo:lo]

是空的，而

    s[lo:lo+1]

有一个元素。

.play prog/slicing-slices.go

* 构造 slice

slice 由函数 `make` 创建。这会分配一个零长度的数组并且返回一个 slice 指向这个数组：

    a := make([]int, 5)  // len(a)=5

为了指定容量，可传递第三个参数到 `make`：

	b := make([]int, 0, 5) // len(b)=0, cap(b)=5

	b = b[:cap(b)] // len(b)=5, cap(b)=5
	b = b[1:]      // len(b)=4, cap(b)=4

.play prog/making-slices.go

* 空 slice
    
slice 的零值是 `nil`。

一个 nil 的 slice 的长度和容量是 0。

（了解更多关于 slice 的内容，参阅文章[[http://golang.org/doc/articles/slices_usage_and_internals.html][slice：使用和内幕]]。）

.play prog/nil-slices.go

# TODO(campoy): Appending to slices section

* range

`for` 循环的 `range` 格式可以对 slice 或者 map 进行迭代循环。

.play prog/range.go

* range（续）

可以将值赋值给 `_` 来忽略序号和值。

如果只需要索引值，去掉“, value”的部分即可。

.play prog/range-continued.go

* 练习：slice

实现 `Pic`。它返回一个 slice 的长度 `dy`，和 slice 中每个元素的长度的 8 位无符号整数 `dx`。当执行这个程序，它会将整数转换为灰度（好吧，蓝度）图片进行展示。

图片的实现已经完成。可能用到的函数包括 `>x^y`，`(x+y)/2` 和 `x*y`。

（需要使用循环来分配 `[][]uint8` 中的每个 `[]uint8`。）

（使用 `uint8(intValue)` 在类型之间进行转换。）

.play prog/exercise-slices.go

* map

map 映射键到值。
        
map 在使用之前必须用 `make` 而不是 `new` 来创建；值为 `nil` 的 map 是空的，并且不能赋值。

.play prog/maps.go

* map 的文法

map 的文法跟结构体文法相似，不过必须有键名。

.play prog/map-literals.go

* map 的文法（续）

如果顶级的类型只有类型名的话，可以在文法的元素中省略键名。

.play prog/map-literals-continued.go

* 修改 map

在 map `m` 中插入或修改一个元素：

    m[key] = elem
        
获得元素：

    elem = m[key]

删除元素：
        
    delete(m, key)

通过双赋值检测某个键存在：

    elem, ok = m[key]

如果 `key` 在 `m` 中，`ok` 为 `true`。否则，`ok` 为 `false`，并且 `elem` 是 map 的元素类型的零值。

同样的，当从 map 中读取某个不存在的键时，结果是 map 的元素类型的零值。

.play prog/mutating-maps.go

# TODO(campoy): Range on maps section

* 练习：map
        
实现 `WordCount`。它应当返回一个含有 `s` 中每个 “词” 个数的 map。函数 `wc.Test` 针对这个函数执行一个测试用例，并打印成功或者失败。

你会发现 [[http://golang.org/pkg/strings/#Fields][strings.Fields]] 很有帮助。

.play prog/exercise-maps.go

* 函数为值

函数也是值。Function values

.play prog/function-values.go

* 函数的闭包

并且函数是完全闭包的。

函数 `adder` 返回一个闭包。每个闭包被绑定到了特定的 `sum` 变量上。

.play prog/function-closures.go

* 练习：斐波纳契闭包

现在来通过函数做些有趣的事情。
        
实现一个 `fibonacci` 函数，返回一个函数（一个闭包）可以返回连续的斐波纳契数。

.play prog/exercise-fibonacci-closure.go

* switch

你可能已经猜到 `switch` 可能的形式了。

除非使用 `fallthrough` 语句作为结尾，否则 case 部分会自动终止。

.play prog/switch.go

* switch 的执行顺序

switch 的条件从上到下的执行，当匹配成功的时候停止。

（例如，
    
    switch i {
    case 0:
    case f():
    }

当 `i==0` 时不会调用 `f`。）

#appengine: 注意：Go playground 中的时间总是从 2009-11-10 23:00:00 UTC 开始，
#appengine: 如何校验这个值作为一个练习留给读者完成。

.play prog/switch-evaluation-order.go

* 没有条件的 switch

没有条件的 switch 同 `switch true` 一样。

这一构造使得可以用更清晰的形式来编写长的 if-then-else 链。

.play prog/switch-with-no-condition.go

* 进阶练习：复数立方根

让我们通过 `complex64` 和 `complex128` 来探索一下 Go 内建的复数。对于立方根，牛顿法需要大量循环：

.image static/newton3.png
        
找到 2 的立方根，确保算法能够工作。在 `math/cmplx` 包中有 [[http://golang.org/pkg/math/cmplx/#Pow][Pow]] 函数。

.play prog/advanced-exercise-complex-cube-roots.go

* 方法和接口

* 方法

Go 没有类。然而，仍然可以在结构体类型上定义方法。

_方法接收者_ 出现在 `func` 关键字和方法名之间的参数中。

.play prog/methods.go

* 方法（续）

事实上，可以对包中的 _任意_ 类型定义任意方法，而不仅仅是针对结构体。

不能对来自其他包的类型或基础类型定义方法。

.play prog/methods-continued.go

* 接收者为指针的方法

方法可以与命名类型或命名类型的指针关联。

刚刚看到的两个 `Abs` 方法。一个是在 `*Vertex` 指针类型上，而另一个在 `MyFloat` 值类型上。
        有两个原因需要使用指针接收者。首先避免在每个方法调用中拷贝值（如果值类型是大的结构体的话会更有效率）。其次，方法可以修改接收者指向的值。

尝试修改 `Abs` 的定义，同时 `Scale` 方法使用 `Vertex` 代替 `*Vertex` 作为接收者。

当 `v` 是 `Vertex` 的时候 `Scale` 方法没有任何作用。`Scale` 修改 `v`。当 `v` 是一个值（非指针），方法看到的是 `Vertex` 的副本，并且无法修改原始值。

`Abs` 的工作方式是一样的。只不过，仅仅读取 `v`。所以读取的是原始值（通过指针）还是那个值的副本并没有关系。

.play prog/methods-with-pointer-receivers.go

* 接口

接口类型是由一组方法定义的集合。

接口类型的值可以存放实现这些方法的任何值。

.play prog/interfaces.go

* 隐式接口
    
类型通过实现那些方法来实现接口。
        
_没有显式声明的必要。_

隐式接口解藕了实现接口的包和定义接口的包：互不依赖。

因此，也就无需在每一个实现上增加新的接口名称，这样同时也鼓励了明确的接口定义。

[[http://golang.org/pkg/io/][包 io]] 定义了 `Reader` 和 `Writer`；其实不一定要这么做。

.play prog/interfaces-are-satisfied-implicitly.go

* 错误

错误是可以用字符串描述自己的任何东西。主要思路是由预定义的内建接口类型 `error`，和方法 `Error`，返回字符串：

    type error interface {
        Error() string
    }

当用 `fmt` 包的多种不同的打印函数输出一个 `error` 时，会自动的调用该方法。

.play prog/errors.go

* 练习：错误

从之前的练习中复制 `Sqrt` 函数，并修改使其返回 `error` 值。      

`Sqrt` 接收到一个负数时，应当返回一个非 nil 的错误值。复数同样也不被支持。
    
创建一个新类型
        
    type ErrNegativeSqrt float64

为其实现

    func (e ErrNegativeSqrt) Error() string

使其成为一个 `error`， 该方法就可以让 `ErrNegativeSqrt(-2).Error()` 返回 `"cannot Sqrt negative number: -2"`。

*注意：* 在 `Error` 方法内调用 `fmt.Print(e)` 将会让程序陷入死循环。可以通过先转换 `e` 来避免这个问题：`fmt.Print(float64(e))`。请思考这是为什么呢？

修改 `Sqrt` 函数，使其接受一个负数时，返回 `ErrNegativeSqrt` 值。

.play prog/exercise-errors.go

* Web 服务器
    
[[http://golang.org/pkg/net/http/][包 http]] 通过任何实现了 `http.Handler` 的值来响应 HTTP 请求：

    package http
	
    type Handler interface {
        ServeHTTP(w ResponseWriter, r *Request)
    }

在这个例子中，类型 `Hello` 实现了 `http.Handler`。

访问 [[http://localhost:4000/][http://localhost:4000/]] 会看到来自程序的问候。
    
#appengine: *注意：* 这个例子无法在基于 web 的指南用户界面运行。为了尝试编写 
#appengine: web 服务器，可能需要[[http://golang.org/doc/install/][安装 Go]]。

.play prog/web-servers.go

* 练习：HTTP 处理

实现下面的类型，并在其上定义 ServeHTTP 方法。在 web 服务器中注册它们来处理指定的路径。

    type String string
	
    type Struct struct {
        Greeting string
        Punct    string
        Who      string
    }

例如，可以使用如下方式注册处理方法：

    http.Handle("/string", String("I'm a frayed knot."))
    http.Handle("/struct", &Struct{"Hello", ":", "Gophers!"})

.play prog/exercise-http-handlers.go

* 图片

[[http://golang.org/pkg/image/#Image][Package image]] 定义了 `Image` 接口：
        
    package image
	
    type Image interface {
	ColorModel() color.Model
	Bounds() Rectangle
	At(x, y int) color.Color
    }

（参阅[[http://golang.org/pkg/image/#Image][文档]]了解全部信息。）

同样，`color.Color` 和 `color.Model` 也是接口，但是通常因为直接使用预定义的实现 `image.RGBAColor` 和 `image.RGBAColorModel` 而被忽视了。

.play prog/images.go

* 练习：图片

还记得之前编写的图片生成器吗？现在来另外编写一个，不过这次将会返回 `image.Image` 来代替 slice 的数据。

自定义的 `Image` 类型，要实现[[http://golang.org/pkg/image/#Image][必要的方法]]，并且调用 `pic.ShowImage`。

`Bounds` 应当返回一个 `image.Rectangle`，例如 `image.Rect(0, 0, w, h)`。

`ColorModel` 应当返回 `image.RGBAColorModel`。

`At` 应当返回一个颜色；在这个例子里，在最后一个图片生成器的值 `v` 匹配 `color.RGBAColor{v, v, 255, 255}`。

.play prog/exercise-images.go

* 练习：Rot13 读取器

一般的模式是 [[http://golang.org/pkg/io/#Reader][io.Reader]] 包裹另一个 `io.Reader`，用某些途径修改特定的流。

例如，[[http://golang.org/pkg/compress/gzip/#NewReader][gzip.NewReader]] 函数输入一个 `io.Reader`（gzip 的数据流）并且返回一个同样实现了 `io.Reader` 的 `*gzip.Reader`（解压缩后的数据流）。
        
实现一个实现了 `io.Reader` 的 `rot13Reader`，用 [[http://en.wikipedia.org/wiki/ROT13][ROT13]] 修改数据流中的所有的字母进行密文替换。

`rot13Reader` 已经提供。通过实现其 `Read` 方法使得它匹配 `io.Reader`。

.play prog/exercise-rot-reader.go

* 并发

* goroutine

_goroutine_ 是由 Go 运行时环境管理的轻量级线程。

    go f(x, y, z)

开启一个新的 goroutine 执行

    f(x, y, z)
        
`f`，`x`，`y` 和 `z` 是当前 goroutine 中定义的，但是在新的 goroutine 中运行 `f`。

goroutine 在相同的地址空间中运行，因此访问共享内存必须进行同步。`[[http://golang.org/pkg/sync/][sync]]` 提供了这种可能，不过在 Go 中并不经常用到，因为有其他的办法。（在接下来的内容中会涉及到。）

.play prog/goroutines.go

* channel

channel 是有类型的管道，可以用 channel 操作符 `<-` 对其发送或者接收值。

    ch <- v    // 将 v 送入 channel ch。
    v := <-ch  // 从 ch 接收，并且赋值给 v。

（“箭头”就是数据流的方向。）

和 map 与 slice 一样，channel 使用前必须创建：

    ch := make(chan int)

默认情况下，在另一端准备好之前，发送和接收都会阻塞。这使得 goroutine 可以在没有明确的锁或竞态变量的情况下进行同步。

.play prog/channels.go

* 缓冲 channel

channel 可以是 _带缓冲的_。为 `make` 提供第二个参数作为缓冲长度来初始化一个缓冲 channel：

	ch := make(chan int, 100)

向缓冲 channel 发送数据的时候，只有在缓冲区满的时候才会阻塞。当缓冲区清空的时候接受阻塞。

修改例子使得缓冲区被填满，然后看看会发生什么。

.play prog/buffered-channels.go

* range 和 close

发送者可以 `close` 一个 channel 来表示再没有值会被发送了。接收者可以通过赋值语句的第二参数来测试 channel 是否被关闭：当没有值可以接收并且 channel 已经被关闭，那么经过

	v, ok := <-ch

之后 `ok` 会被设置为 `false`。

循环 `for i := range c` 会不断从 channel 接收值，直到它被关闭。
        
*注意：* 只有发送者才能关闭 channel，而不是接收者。向一个已经关闭的 channel 发送数据会引起 panic。
*还要注意：* channel 与文件不同；通常情况下无需关闭它们。只有在需要告诉接收者没有更多的数据的时候才有必要进行关闭，例如中断一个 `range`。

.play prog/range-and-close.go

* select
        
`select` 语句使得一个 goroutine 在多个通讯操作上等待。

`select` 会阻塞，直到条件分支中的某个可以继续执行，这时就会执行那个条件分支。当多个都准备好的时候，会随机选择一个。

.play prog/select.go

* 默认选择

当 `select` 中的其他条件分支都没有准备好的时候，`default` 分支会被执行。

为了非阻塞的发送或者接收，可使用 `default` 分支：

    select {
    case i := <-c:
    	// 使用 i
    default:
	// 从 c 读取会阻塞
    }
        
.play prog/default-selection.go

* 练习：等价二叉树

可以用多种不同的二叉树的叶子节点存储相同的数列值。例如，这里有两个二叉树保存了序列 1，1，2，3，5，8，13。

.image static/tree.png

用于检查两个二叉树是否存储了相同的序列的函数在多数语言中都是相当复杂的。这里将使用 Go 的并发和 channel 来编写一个简单的解法。

这个例子使用了 `tree` 包，定义了类型：

    type Tree struct {
        Left  *Tree
        Value int
        Right *Tree
    }

* 练习：等价二叉树

*1.* 实现 `Walk` 函数。

*2.* 测试 `Walk` 函数。

函数 `tree.New(k)` 构造了一个随机结构的二叉树，保存了值 `k`，`2k`，`3k`，...，`10k`。
创建一个新的 channel `ch` 并且对其进行步进：

    go Walk(tree.New(1), ch)

然后从 channel 中读取并且打印 10 个值。应当是值 1，2，3，...，10。
    
*3.* 用 `Walk` 实现 `Same` 函数来检测是否 `t1` 和 `t2` 存储了相同的值。

*4.* 测试 `Same` 函数。

`Same(tree.New(1), tree.New(1))` 应当返回 true，而 `Same(tree.New(1), tree.New(2))` 应当返回 false。

.play prog/exercise-equivalent-binary-trees.go

* 练习：Web 爬虫

在这个练习中，将会使用 Go 的并发特性来并行执行 web 爬虫。

修改 `Crawl` 函数来并行的抓取 URLs，并且保证不重复。

.play prog/exercise-web-crawler.go

* Where to Go from here...

#appengine: 你可以从
#appengine: [[http://golang.org/doc/install/][安装 Go]] 开始，或者下载
#appengine: [[http://code.google.com/appengine/downloads.html#Google_App_Engine_SDK_for_Go][Go App Engine SDK]].

#appengine: 一旦安装了 Go，
[[http://golang.org/doc/][Go 文档]] 是一个极好的
#appengine: 应当继续阅读的内容。
开始。
它包含了参考、指南、视频等等更多资料。

了解如何组织 Go 代码并在其上工作，参阅 [[http://www.youtube.com/watch?v=XCsL89YtqCs][这个视频]]，或者阅读 [[http://golang.org/doc/code.html][如何编写 Go 代码]]。
        
在标准库上需要帮助的话，参考 [[http://golang.org/pkg/][包手册]]。语言本身的帮助，阅读 [[http://golang.org/ref/spec][语言规范]]是件令人愉快的事情。

进一步探索 Go 的并发模型，参阅 [[http://golang.org/doc/codewalk/sharemem/][Share Memory by Communicating]] 的代码之旅。
        
[[http://golang.org/doc/codewalk/functions/][First Class Functions in Go]] 展示了有趣的函数类型。
        
[[http://blog.golang.org/][Go Blog]] 有着众多的关于 Go 的文章信息。

[[http://www.mikespook.com/tag/golang/][mikespook 的博客]]有大量中文的关于 Go 的文章和翻译。

开源电子书 [[https://github.com/astaxie/build-web-application-with-golang][Go Web 编程]] 和 [[https://github.com/Unknwon/the-way-to-go_ZH_CN][Go入门指南]] 能够帮助你更加深入的了解和学习 Go 语言。
        
访问 [[http://golang.org][golang.org]] 了解更多内容。
